@startuml

class Runnable

package "wireformats" #DDDDDD {

	interface Event {
		getBytes() : byte[]
		getType() :	byte
	}

	interface Protocol {
		{static} byte OVERLAY_NODE_SENDS_REGISTRATION
		typeString(byte b) : String
	}

	class EventFactory {
		getInstance() : EventFactory
		createEvent(byte type, DataInputStream din, String receivedFrom) throws IOException: Event
	}

	class NodeReportsOverlaySetupStatus {
		+status : int
		+infoString : String
		NodeReportsOverlaySetupStatus(int status, String infoString)
		NodeReportsOverlaySetupStatus(DataInputStream din) throws IOException
	}

	class OverlayNodeReportsTaskFinished {
		+port : int
		+id : int
		+messageIPString : String
		OverlayNodeReportsTaskFinished(int port, int id)
		OverlayNodeReportsTaskFinished(DataInputStream din) throws IOException
	}

	 	Event <|-- NodeReportsOverlaySetupStatus
	 	Event <|-- OverlayNodeReportsTaskFinished
}

package "node" #DDDDDD {
	
	interface Node {
		onEvent(Event)
		setPortBound(boolean)
		handleUserInput(String)
	}

	class MessagingNode {
		+main(String[])
		-usageErrorExit()
		+setPortBound(boolean)
		-waitForBind()
		-startCommandParser()
		-createServerThread(TCPConnectionCache)
		+onEvent(Event)
		+handleUserInput(String input)
		..
		-MessagingNode(String host, int port)
		--
		-register(TCPConnection)
		-sendDataMessage()
		-printCountersAndDiagnostics()
		-deregister()
		==
		-handleRegistryRequestsTrafficSummary()
		-handleOverlayNodeSendsData(OverlayNodeSendsData)
		-relayMessage(OverlayNodeSendsData)
		-handleRegistryRequestsTaskInitiate(RegistryRequestsTaskInitiate)
		-receiveNodeManifest(RegistrySendsNodeManifest)
		-handleDeregistrationResponse(RegistryReportsDeregistrationStatus)
		-handleRegistrationResponse(RegistryReportsRegistrationStatus)
	}

	class Registry {
		+main(String[])
		-usageErrorExit()
		+setPortBound(boolean)
		-waitForPortBind()
		-startCommandParser()
		-createServerThread(TCPConnectionCache)
		+onEvent(Event)
		+handleUserInput(String input)
		..
		-Registry(int port)
		--
		-listRoutingTables()
		-listMessagingNodes()
		-initiateDataTransfer(int)
		-requestTrafficSummaries()
		-setupOverlay(int)
		-createRoutingEntry(int currentIndex, int power) : RoutingEntry
		+createNewID()
		==
		-handleOverlayNodeReportsTrafficSummary(OverlayNodeReportsTrafficSummary)
		-handleOverlayNodeReportsTaskFinished(OverlayNodeReportsTaskFinished)
		-handleNodeReportsOverlaySetupStatus(NodeReportsOverlaySetupStatus)
		-attemptToDeregister(OverlayNodeSendsDeregistration)
		-attemptToRegister(OverlayNodeSendsRegistration)
	}

	Node <|-- MessagingNode
	Node <|-- Registry
}

package "routing" #DDDDDD {
	
	class RoutingEntry {
		+nodeID : int
		+port : int
		+address : byte[]
		+RoutingEntry(int id, String ip, int port)
		+RoutingEntry(int id, byte[] ip, int port)
	}

	class RoutingTable {
		+entryList : ArrayList<RoutingEntry>
		+ownerID : int
		+RoutingTable()
		+RoutingTalbe(int ownerID)
		+addEntry(RoutingEntry entry)
		+getSize() : byte
		+routeTo(int id) : RoutingEntry
	}

	RoutingTable::entryList -> RoutingEntry
	RoutingTable::routeTo -> RoutingEntry
}

package "transport" #DDDDDD {
	class TCPConnection {
		+uniqueID : int
		-socket : Socket
		+listeningPort : int
		+remoteIP : String
		-sender : TCPSender
		+TCPConnection(Socket s)
		+send(Event event)
		+getSocket() : Socket
	}

	class TCPConnectionCache {
		+node : Node
		-registry : TCPConnection
		+connectionList : ArrayList<TCPConnection>
		+TCPConnectionCache(Node n)
		+addRegistry(TCPConnection c)
		+addConnection(TCPConnection c)
		+getRegistry() : TCPConnection
		+getRegisteredCount() : int
		+contains(TCPConnection c) : boolean
		+getByID(int id) : TCPConnection
		+get(int port, String ip) : TCPConnection
		+remove(TCPConnection c) : boolean
	}
	class TCPReceiverThread {
		-socket : Socket
		-ownerNode : Node
		+TCPReceiverThread(Socket s, TCPConnectionCache cc)
		+run()
	}
	class TCPSender {
		-socket : Socket
		+TCPSender(Socket s)
		+TCPSender(Socket s, Event event)
		+sendMessage(Event event)
	}
	class TCPServerThread {
		+port : int
		-serverSocket : ServerSocket
		-cc : TCPConnectionCache
		+TCPServerThread(TCPConnectionCache cc)
		+TCPServerThread(int port, TCPConnectionCache cc)
		-bindSuccess() throws IOException : boolean
		+run()
	}

	.Runnable <|-- TCPReceiverThread
	.Runnable <|-- TCPServerThread
}

package "util" #DDDDDD {
	class InteractiveCommandParser {
		-node Node
		-scanner Scanner
		+InteractiveCommandParser(Node n)
		+run()
	}
	class StatisticsCollectorAndDisplay {
		-nodeReports : ArrayList<OverlayNodeReportsTrafficSummary>
		+StatisticsCollectorAndDisplay()
		+addReport(OverlayNodeReportsTrafficSummary report)
		+showStatistics()
	}
	.Runnable <|-- InteractiveCommandParser
}
Registry -[hidden]d- RoutingTable
TCPServerThread -[hidden]d- TCPConnection
TCPServerThread -[hidden]d- TCPConnectionCache
InteractiveCommandParser -[hidden]d- StatisticsCollectorAndDisplay

@enduml